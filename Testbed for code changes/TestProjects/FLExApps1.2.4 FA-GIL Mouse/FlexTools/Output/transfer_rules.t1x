<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE transfer PUBLIC "-//XMLmind//DTD transfer//EN"
"transfer.dtd">
<transfer>
  <section-def-cats>
    <def-cat n="adj">
      <cat-item tags="adj"/>
      <cat-item tags="adj.*"/>
    </def-cat>
    <def-cat n="adv-ham">
      <cat-item lemma="هم2.1" tags="adv"/>
    </def-cat>
    <def-cat n="adv">
      <cat-item tags="adv"/>
    </def-cat>
    <def-cat n="nom_ind"> <!-- we don't need n.*.ind because ita before a plural n doesn't make sense. -->
      <cat-item tags="n.ind"/>
      <cat-item tags="n.ind.*"/>
      <cat-item tags="n-irreg.ind" />
      <cat-item tags="n-irreg.ind.*" />
    </def-cat>
    <def-cat n="nom_pc">
      <cat-item tags="*.pc_1sg"/>
      <cat-item tags="*.pc_2sg"/>
      <cat-item tags="*.pc_3sg"/>
      <cat-item tags="*.pc_1pl"/>
      <cat-item tags="*.pc_2pl"/>
      <cat-item tags="*.pc_3pl"/>
    </def-cat>
    <def-cat n="nom">
      <cat-item tags="n"/>
      <cat-item tags="n.*" />
      <cat-item tags="n-irreg" />
      <cat-item tags="n-irreg.*" />
    </def-cat>
    <def-cat n="nom-adj-pro">
      <cat-item tags="adj"/>
      <cat-item tags="adj.*"/>
      <cat-item tags="n"/>
      <cat-item tags="n.*"/>
      <cat-item tags="pro"/>
      <cat-item tags="pro.*"/> <!-- 2pl shoma sometimes has a plural ending -->
    </def-cat>
    <def-cat n="nom-adv">
      <cat-item tags="adv"/>
      <cat-item tags="n"/>
      <cat-item tags="n.*"/>
    </def-cat>
    <def-cat n="nom-adv-pro">
      <cat-item tags="adv"/>
      <cat-item tags="n"/>
      <cat-item tags="n.*"/>
      <cat-item tags="pro"/>
      <cat-item tags="pro.*"/> <!-- 2pl shoma sometimes has a plural ending -->
    </def-cat>
    <def-cat n="post">
      <cat-item tags="post"/>
    </def-cat>
    <def-cat n="prep">
      <cat-item tags="prep"/>
      <cat-item tags="nprep"/>
      <cat-item tags="nprep.*"/>
    </def-cat>
    <def-cat n="pro">
      <cat-item tags="pro"/>
      <cat-item tags="pro.*"/> <!-- 2pl shoma sometimes has a plural ending -->
    </def-cat>
    <def-cat n="vrb-cop-prs">
      <cat-item tags="cop.prs.*"/>
    </def-cat>
    <def-cat n="vrb-cop-pst">
      <cat-item tags="cop.pst.*"/>
      <cat-item tags="aux.pst.*"/>
    </def-cat>
    <def-cat n="vrb-cop-prs-3sg">
      <!-- we know this is ast because it has no person number suffix 
           it's just cop.prs and nothing else. -->
      <cat-item tags="cop.prs"/>
    </def-cat>
    <def-cat n="vrb-imp">
      <cat-item tags="*.imp"/>
    </def-cat>
    <def-cat n="vrb-inf">
      <cat-item tags="*.inf"/>
      <cat-item tags="*.inf.ez"/>
    </def-cat>
    <def-cat n="vrb-ipfv">
      <cat-item tags="*.pst.ipfv.*"/>
      <cat-item tags="*.pst.neg.ipfv.*"/>
    </def-cat>
    <def-cat n="vrb-prpt">    
      <cat-item tags="*.prpt"/>
    </def-cat>
    <def-cat n="vrb-prs">
      <cat-item tags="v.prs.*"/>
      <cat-item tags="vcomp.prs.*"/>
      <cat-item tags="vphrase.prs.*"/>
    </def-cat>
    <def-cat n="vrb-pst">
      <cat-item tags="v.pst.*"/>
      <cat-item tags="v.prs.caus_pst.*"/>
      <cat-item tags="vcomp.pst.*"/>
      <cat-item tags="vphrase.pst.*"/>
    </def-cat>
    <def-cat n="x">
      <cat-item tags="adj"/>
      <cat-item tags="adj.*"/>
      <cat-item tags="n"/>
      <cat-item tags="n.*"/>
      <cat-item tags="pro"/>
      <cat-item tags="dem"/>
    </def-cat>
   
  </section-def-cats>
  <section-def-attrs>
    
    <def-attr n="asp">
      <attr-item tags="ipfv"/>
    </def-attr>
       
    <def-attr n="caus">
      <attr-item tags="caus_pst"/>
    </def-attr>
    
     <def-attr n="ezafe">
      <attr-item tags="ez"/>
    </def-attr>
    
    <def-attr n="nbr">
      <attr-item tags="sg"/>
      <attr-item tags="pl"/>
    </def-attr>

    <def-attr n="ipfv">
      <attr-item tags="ipfv"/>
    </def-attr>
    
    <def-attr n="neg">
      <attr-item tags="neg"/>
    </def-attr>
    
    <def-attr n="per-nbr">
      <attr-item tags="1sg"/>
      <attr-item tags="2sg"/>
      <attr-item tags="3sg_cop_prs"/>
      <attr-item tags="3sg_prs"/>
      <attr-item tags="3sg_pst"/>
      <attr-item tags="1pl"/>
      <attr-item tags="2pl"/>
      <attr-item tags="3pl"/>
      <attr-item tags="inf"/>
      <attr-item tags="imp"/>
      <attr-item tags="pspt"/>
    </def-attr>
       
    <def-attr n="pron-clitic">
      <attr-item tags="pc_1sg"/>
      <attr-item tags="pc_2sg"/>
      <attr-item tags="pc_3sg"/>
      <attr-item tags="pc_1pl"/>
      <attr-item tags="pc_2pl"/>
      <attr-item tags="pc_3pl"/>
    </def-attr>
       
    <def-attr n="prpt">
      <attr-item tags="prpt"/>
    </def-attr>
       
    <def-attr n="sbjv">
      <attr-item tags="sbjv"/>
    </def-attr>
    
    <def-attr n="sl_pos">
      <attr-item tags="adj"/>
      <attr-item tags="adv"/>
      <attr-item tags="aux"/>
      <attr-item tags="cop"/>
      <attr-item tags="conn"/>
      <attr-item tags="deg"/>
      <attr-item tags="dem"/>
      <attr-item tags="n"/>
      <attr-item tags="n-irreg"/>
      <attr-item tags="nprep"/>
      <attr-item tags="nprop"/>
      <attr-item tags="num"/>
      <attr-item tags="post"/>
      <attr-item tags="pro"/>
      <attr-item tags="prep"/>
      <attr-item tags="prt"/>
      <attr-item tags="q"/>
      <attr-item tags="quant"/>
      <attr-item tags="v"/>
      <attr-item tags="vphrase"/>
      <attr-item tags="vpst-sp"/>
    </def-attr>

    <def-attr n="tense">
      <attr-item tags="pst"/>
      <attr-item tags="prs"/>
    </def-attr>
    
    <def-attr n="tl_pos">
      <attr-item tags="adj"/>
      <attr-item tags="aux"/>
      <attr-item tags="cop"/>
      <attr-item tags="dem"/>
      <attr-item tags="n"/>
      <attr-item tags="nprop"/>
      <attr-item tags="post"/>
      <attr-item tags="pro"/>
      <attr-item tags="vcmplx"/>
      <attr-item tags="vprs"/>
      <attr-item tags="vpst"/>
      <attr-item tags="vpst-sp"/>
    </def-attr>
  </section-def-attrs>
  <section-def-vars>
    <def-var n="3sg_var"/>
    <def-var n="caus_var"/>
    <def-var n="per_number"/>
    <def-var n="gen_pro"/>
    <def-var n="acc_pro"/>
    <def-var n="gram_cat"/>
  </section-def-vars>  
  <section-def-lists>
    <def-list n="end_vowels">
      <list-item v="ا1.1"/>
      <list-item v="ا1.2"/>
      <list-item v="ا1.3"/>
      <list-item v="ا1.4"/>
      <list-item v="ا1.5"/>
      <list-item v="ا2.1"/>
      <list-item v="ا2.2"/>
      <list-item v="ا2.3"/>
      <list-item v="ا2.4"/>
      <list-item v="ا2.5"/>
      <list-item v="ا3.1"/>
      <list-item v="ا3.2"/>
      <list-item v="ا3.3"/>
      <list-item v="ا3.4"/>
      <list-item v="ا4.5"/>
      <list-item v="ا4.1"/>
      <list-item v="ا4.2"/>
      <list-item v="ا4.3"/>
      <list-item v="ا4.4"/>
      <list-item v="ا4.5"/>
      <list-item v="و1.1"/>
      <list-item v="و1.2"/>
      <list-item v="و1.3"/>
      <list-item v="و1.4"/>
      <list-item v="و1.5"/>
      <list-item v="و2.1"/>
      <list-item v="و2.2"/>
      <list-item v="و2.3"/>
      <list-item v="و2.4"/>
      <list-item v="و2.5"/>
      <list-item v="و3.1"/>
      <list-item v="و3.2"/>
      <list-item v="و3.3"/>
      <list-item v="و3.4"/>
      <list-item v="و4.5"/>
      <list-item v="و4.1"/>
      <list-item v="و4.2"/>
      <list-item v="و4.3"/>
      <list-item v="و4.4"/>
      <list-item v="و4.5"/>
      <list-item v="ی1.1"/>
      <list-item v="ی1.2"/>
      <list-item v="ی1.3"/>
      <list-item v="ی1.4"/>
      <list-item v="ی1.5"/>
      <list-item v="ی2.1"/>
      <list-item v="ی2.2"/>
      <list-item v="ی2.3"/>
      <list-item v="ی2.4"/>
      <list-item v="ی2.5"/>
      <list-item v="ی3.1"/>
      <list-item v="ی3.2"/>
      <list-item v="ی3.3"/>
      <list-item v="ی3.4"/>
      <list-item v="ی4.5"/>
      <list-item v="ی4.1"/>
      <list-item v="ی4.2"/>
      <list-item v="ی4.3"/>
      <list-item v="ی4.4"/>
      <list-item v="ی4.5"/>
      <list-item v="ه1.1"/>
      <list-item v="ه1.2"/>
      <list-item v="ه1.3"/>
      <list-item v="ه1.4"/>
      <list-item v="ه1.5"/>
      <list-item v="ه2.1"/>
      <list-item v="ه2.2"/>
      <list-item v="ه2.3"/>
      <list-item v="ه2.4"/>
      <list-item v="ه2.5"/>
      <list-item v="ه3.1"/>
      <list-item v="ه3.2"/>
      <list-item v="ه3.3"/>
      <list-item v="ه3.4"/>
      <list-item v="ه4.5"/>
      <list-item v="ه4.1"/>
      <list-item v="ه4.2"/>
      <list-item v="ه4.3"/>
      <list-item v="ه4.4"/>
      <list-item v="ه4.5"/>
    </def-list> 
    <def-list n="rev_adjs">
      <list-item v="راست1.1"/>
      <list-item v="کنار1.1"/>
    </def-list> 
    <def-list n="special_prep">
      <list-item v="به1.1"/>
      <list-item v="برای1.1"/>
    </def-list> 
    <!--  These are verbs that take a special form for 3sg past. Namely null or he  --> 
    <def-list n="3sg_pst_verbs">
      <list-item v="اَمون1.1"/>
      <list-item v="ایسَن1.1"/>
      <list-item v="ایسَن1.2"/>
      <list-item v="ایسَن1.3"/>
      <list-item v="بوئن1.1"/>
      <list-item v="بوئن1.2"/>
      <list-item v="ترسئن1.1"/>
      <list-item v="چِئن1.1"/>
      <list-item v="دَئن1.1"/>
      <list-item v="شهادت دَئن1.1"/>
      <list-item v="قورت دَئن1.1"/>
      <list-item v="دِئن1.1"/>
      <list-item v="رسن1.1"/>
      <list-item v="رسن1.2"/>
      <list-item v="زِئن1.1"/>
      <list-item v="شوئون1.1"/>
      <list-item v="فدن1.1"/>
      <list-item v="فَرسن1.1"/>
      <list-item v="فکشن1.1"/>
      <list-item v="کشن1.1"/>
      <list-item v="نَئن1.1"/>
      <list-item v="هِئن1.1"/>
      <list-item v="وَورسن1.1"/>
      <list-item v="وزِئن1.1"/>
    </def-list>  
  </section-def-lists>
  <section-def-macros>
    <!--  change 2pl or 3pl to 2/3pl  -->
    <def-macro n="2_3_pl_macro" npar="1">    
      <choose>
        <when>
          <test>
            <or>
              <equal>
                <clip pos="1" side="tl" part="per-nbr"/>
                <lit-tag v="3pl"/>
              </equal>
              <equal>
                <clip pos="1" side="tl" part="per-nbr"/>
                <lit-tag v="2pl"/>
              </equal>
            </or>
          </test>
          <let>
            <var n="per_number"/>
            <lit-tag v="2/3pl"/>
          </let>
        </when>
        <otherwise>
          <let>
            <var n="per_number"/>
            <clip pos="1" side="tl" part="per-nbr"/>
          </let>
        </otherwise>
      </choose>
    </def-macro>
    <!-- If the suffix is 3sg_pst, change it to 3sg unless the lemma is one of the verbs that ends in a vowel or he or fatah -->
    <def-macro n="3sg_pst_macro" npar="1">    
      <choose>
        <when>
          <test>
            <and>
              <equal>
                <clip pos="1" side="sl" part="per-nbr"/>
                <lit-tag v="3sg_pst"/>
              </equal>
              <not>
                <in> 
                  <clip pos="1" side="tl" part="lem"/>
                  <list v="3sg_pst_verbs"/>
                </in>
              </not>
            </and>
          </test>
          <let>
            <var n="per_number"/>
            <lit-tag v="3sg"/>
          </let>
        </when>
      </choose>
    </def-macro>
    <!-- Check the 6 different person number situations and set a variable to the appropriate gilaki genitive pronoun -->
    <def-macro n="gen_pro_macro" npar="1">
      <let> <!-- initialize variable to null -->
        <var n="gen_pro"/>
        <lit v=""/>
      </let>
      <let> <!-- initialize variable to null -->
        <var n="gram_cat"/>
        <lit v=""/>
      </let>
      <choose> 
        <when> <!-- 1sg -->
          <test>
            <equal>
              <clip pos="1" side="sl" part="pron-clitic"/>
              <lit-tag v="pc_1sg"/>
            </equal>
          </test>
          <let>
            <var n="gen_pro"/>
            <lit v="می2.1"/>
          </let>
        </when>
        <when> <!-- 2sg -->
          <test>
            <equal>
              <clip pos="1" side="sl" part="pron-clitic"/>
              <lit-tag v="pc_2sg"/>
            </equal>
          </test>
          <let>
            <var n="gen_pro"/>
            <lit v="تی1.1"/>
          </let>
        </when>
        <when> <!-- 3sg -->
          <test>
            <equal>
              <clip pos="1" side="sl" part="pron-clitic"/>
              <lit-tag v="pc_3sg"/>
            </equal>
          </test>
          <let>
            <var n="gen_pro"/>
            <lit v="خو1.1"/>
          </let>
        </when>
        <when> <!-- 1pl -->
          <test>
            <equal>
              <clip pos="1" side="sl" part="pron-clitic"/>
              <lit-tag v="pc_1pl"/>
            </equal>
          </test>
          <let>
            <var n="gen_pro"/>
            <lit v="اَمی1.1"/>
          </let>
        </when>
        <when> <!-- 2pl -->
          <test>
            <equal>
              <clip pos="1" side="sl" part="pron-clitic"/>
              <lit-tag v="pc_2pl"/>
            </equal>
          </test>
          <let>
            <var n="gen_pro"/>
            <lit v="شیمی1.1"/>
          </let>
        </when>
        <when> <!-- 3pl -->
          <test>
            <equal>
              <clip pos="1" side="sl" part="pron-clitic"/>
              <lit-tag v="pc_3pl"/>
            </equal>
          </test>
          <let>
            <var n="gen_pro"/>
            <lit v="اوشأنٚ1.1"/>
          </let>
        </when>
      </choose>
      <choose>
        <when> <!-- if gen_pro variable is not null, set the grammatical category variable -->
          <test>
            <not>
              <equal>
                <var n="gen_pro"/>
                <lit v=""/>
              </equal>
            </not>
          </test>
          <let>
            <var n="gram_cat"/>
            <lit-tag v="perspro"/>  
          </let>
        </when>
      </choose>
    </def-macro>
    <def-macro n="acc_pro_macro" npar="1">
      <let> <!-- initialize the variable to null -->
        <var n="acc_pro"/>
        <lit v=""/>
      </let>
      <let> <!-- initialize the variable to null -->
        <var n="gram_cat"/>
        <lit v=""/>
      </let>
      <choose> <!-- see if we have one of the main pronouns. Note, other pronouns will come through. We want to leave them alone. -->
        <when> <!-- 2sg --> <!-- no 1sg because that's handled lexically -->
          <test> 
            <equal>
              <clip pos="1" side="sl" part="lem"/>
              <lit v="تو1.1"/>
            </equal>
          </test>
          <let>
            <var n="acc_pro"/>
            <lit v="ترَ1.1"/>
          </let>
        </when>
        <when> <!-- 3sg u -->
          <test> 
            <equal>
              <clip pos="1" side="sl" part="lem"/>
              <lit v="او1.1"/>
            </equal>
          </test>
          <let>
            <var n="acc_pro"/>
            <lit v="اونَ1.1"/>
          </let>
        </when>
        <when> <!-- 3sg a:n -->
          <test> 
            <equal>
              <clip pos="1" side="sl" part="lem"/>
              <lit v="آن1.2"/>
            </equal>
          </test>
          <let>
            <var n="acc_pro"/>
            <lit v="اونَ1.1"/>
          </let>
        </when>
        <when> <!-- 1pl -->
          <test> 
            <equal>
              <clip pos="1" side="sl" part="lem"/>
              <lit v="ما1.1"/>
            </equal>
          </test>
          <let>
            <var n="acc_pro"/>
            <lit v="اَمَرَ1.1"/>
          </let>
        </when>
        <when> <!-- 2pl -->
          <test> 
            <equal>
              <clip pos="1" side="sl" part="lem"/>
              <lit v="شما1.1"/>
            </equal>
          </test>
          <let>
            <var n="acc_pro"/>
            <lit v="شمرَ1.1"/>
          </let>
        </when>
        <when> <!-- 3pl -->
          <test> 
            <equal>
              <clip pos="1" side="sl" part="lem"/>
              <lit v="آنها1.1"/>
            </equal>
          </test>
          <let>
            <var n="acc_pro"/>
            <lit v="اوشأنَ1.1"/>
          </let>
        </when>
      </choose>
      <choose>
        <when> <!-- if acc_pro variable is not null, set the grammatical category variable -->
          <test>
            <not>
              <equal>
                <var n="acc_pro"/>
                <lit v=""/>
              </equal>
            </not>
          </test>
          <let>
            <var n="gram_cat"/>
            <lit-tag v="perspro"/>  
          </let>
        </when>
      </choose>
    </def-macro>
  </section-def-macros>
  <section-rules>
    <rule comment="0.5 - convert possessive pronominal enclitics to genitive pronouns"> 
      <pattern>
        <pattern-item n="nom_pc"/>
      </pattern>
      <action>
        <!-- Set the gen_pro variable to the appropriate Gilaki genitive pronoun. -->
        <call-macro n="gen_pro_macro">
          <with-param pos="1"/>
        </call-macro>
        <out>
          <lu>
            <var n="gen_pro"/>   
            <lit-tag v="perspro"/>
          </lu>
          <b/>
          <lu>
            <clip pos="1" side="tl" part="lem"/>   
            <clip pos="1" side="tl" part="tl_pos"/>   
            <clip pos="1" side="tl" part="nbr"/>   <!-- if it exists -->
          </lu>
        </out>
      </action>
    </rule>
    <rule comment="0.7 - convert the indefinite enclitic to the Gilaki indefinite particle"> 
      <pattern>
        <pattern-item n="nom_ind"/>
      </pattern>
      <action>
        <out>
          <lu>
            <lit v="ایتأ1.2"/>   
            <lit-tag v="indf"/>
          </lu>
          <b/>
          <lu>
            <clip pos="1" side="tl" part="lem"/>   
            <clip pos="1" side="tl" part="tl_pos"/>   
            <clip pos="1" side="tl" part="nbr"/>   <!-- if it exists -->
            <clip pos="1" side="tl" part="ezafe"/> <!-- possible ezafe -->
          </lu>
        </out>
      </action>
    </rule>
    <!-- removed rule 1 because of interference with other rules -->
    <rule comment="2-handle noun or adjective or pronoun plus the postposition rā (This is the only postposition in the language.)"> 
      <!-- If there is a pron. enclitic on the noun/adj, map it to the gilaki genitive pronoun and put it in front. -->
      <pattern>
        <pattern-item n="nom-adj-pro"/>
        <pattern-item n="post"/>
      </pattern>
      <action>
        <!-- set the gen_pro variable if there's a pron. enclitic -->
        <call-macro n="gen_pro_macro">
            <with-param pos="1"/>
        </call-macro>
        <!-- set the acc_pro variable if we have a pronoun -->
        <call-macro n="acc_pro_macro">
            <with-param pos="1"/>
        </call-macro>
        <choose>
          <when> <!-- if gen_pro variable is not null, output two words, the genitive pronoun and the noun -->
            <test>
              <not>
                <equal>
                  <var n="gen_pro"/>
                  <lit v=""/>
                </equal>
              </not>
            </test>
            <out>
              <lu>
                <var n="gen_pro"/>   
                <lit-tag v="perspro"/>
              </lu>
              <b/>
              <lu>
                <clip pos="1" side="tl" part="lem"/>   
                <clip pos="1" side="tl" part="tl_pos"/>   
                <clip pos="1" side="tl" part="nbr"/>   <!-- if it exists -->
                <lit-tag v="acc/dat"/>
              </lu>
            </out>
          </when>
          <otherwise> <!-- we don't have a pron enclitic -->
            <choose>
              <when> <!-- if acc_pro variable is not null, output the acc form in Gilaki -->
                <test>
                  <not>
                    <equal>
                      <var n="acc_pro"/>
                      <lit v=""/>
                    </equal>
                  </not>
                </test>
                <out>
                  <lu>
                    <var n="acc_pro"/>   
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <otherwise> <!-- if we have a regular noun without a pronominal enclitic or non-personal pronoun, output the whole thing + acc/dat -->
                <out>
                  <lu>
                    <clip pos="1" side="tl" part="whole"/>
                    <lit-tag v="acc/dat"/>
                  </lu>
                </out>
              </otherwise>
            </choose>
          </otherwise>
        </choose>
      </action>
    </rule>    
    <rule comment="2.5 - convert noun/adv/pro plus the adverb 'ham' to an enclitic."> 
      <pattern>
        <pattern-item n="nom-adv-pro"/>
        <pattern-item n="adv-ham"/> 
      </pattern>
      <action>
        <out>
          <lu>
            <clip pos="1" side="tl" part="whole"/>  
            <lit-tag v="also"/>
          </lu>
        </out>
      </action>
    </rule>    
    <rule comment="2.6- convert noun/adv/pro plus ra plus the adverb 'ham' to an enclitic and omit the accusative."> 
      <pattern>
        <pattern-item n="nom-adv-pro"/>
        <pattern-item n="post"/>
        <pattern-item n="adv-ham"/>
      </pattern>
      <action>
        <!-- set the acc_pro variable if we have a pronoun -->
        <call-macro n="acc_pro_macro">
            <with-param pos="1"/>
        </call-macro>
        <choose>
          <when> 
            <test>
                <equal>
                  <var n="acc_pro"/>
                  <lit v=""/>
                </equal>
            </test>
            <let>
              <var n="acc_pro"/>
              <clip pos="1" side="tl" part="whole"/> 
              <!-- we don't need the accusative encltic because of the ham enclitic --> 
            </let>
          </when>
        </choose>
        <out>
          <lu>
            <var n="acc_pro"/>  
            <var n="gram_cat"/>  
            <lit-tag v="also"/>
          </lu>
        </out>
      </action>
    </rule>    
    <rule comment="3-handle preposition and a pronoun"> 
      <pattern>
        <pattern-item n="prep"/>
        <pattern-item n="pro"/>
      </pattern>
      <action>
        <choose>
          <!-- If the prep is به output either the acc/dat pronoun or the acc/dat tag -->
          <when>
            <test>
              <equal>
                <clip pos="1" side="sl" part="lem"/>
                <lit v="به1.1"/>
              </equal>
            </test>
            <!-- See if we have a 1/2 sg/pl pronoun  -->
            <choose>
              <when> <!-- Pronoun is 1sg - man -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="من1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="مرَ1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <when> <!-- Pronoun is 2sg - to -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="تو1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="ترَ1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <when> <!-- Pronoun is 1pl - ma -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="ما1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="اَمَرَ1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <when> <!-- Pronoun is 2pl - shoma -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="شما1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="شمرَ1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <otherwise> <!-- Output the whole Gilaki word plus the <acc/dat> suffix. E.g. be vey -> un<acc/dat> -> una -->
                <out>
                  <lu>
                    <clip pos="2" side="tl" part="whole"/>  
                    <lit-tag v="acc/dat"/>
                  </lu>
                </out>
              </otherwise>
            </choose>
          </when>
          <!-- If the prep is برای add the ben tag -->
          <when>
            <test>
              <equal>
                <clip pos="1" side="sl" part="lem"/>
                <lit v="برای1.1"/>
              </equal>
            </test>
            <choose>
              <when> <!-- Pronoun is 1sg - man -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="من1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="می‌ره1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <when> <!-- Pronoun is 2sg - to -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="تو1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="تی‌ره1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <when> <!-- Pronoun is 1pl - ma -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="ما1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="اَمی‌ره1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <when> <!-- Pronoun is 2pl - shoma -->
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="شما1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="شیمی‌ره1.1"/>
                    <lit-tag v="perspro"/>
                  </lu>
                </out>
              </when>
              <otherwise>
                <out> <!-- Output the whole Gilaki word plus the <ben> suffix. -->
                  <lu>
                    <clip pos="2" side="tl" part="whole"/>  
                    <lit-tag v="ben"/>
                  </lu>
                </out>
              </otherwise>
            </choose>
          </when>
          <!-- If the prep corresponds to a postposition put it after the pronoun -->
          <when>
            <test>
              <equal>
                <clip pos="1" side="tl" part="tl_pos"/>
                <lit-tag v="post"/>
              </equal>
            </test>
            <!-- For 1/2 sg/pl pronouns output a specific Gilaki pronoun for genitive -->
            <choose>
              <!-- Pronoun is man -->
              <when>
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="من1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="می1.1"/>
                    <clip pos="1" side="tl" part="whole"/>  
                  </lu>
                </out>
              </when>
              <!-- Pronoun is to -->
              <when>
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="تو1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="تی1.1"/>
                    <clip pos="1" side="tl" part="whole"/>
                  </lu>
                </out>
              </when>
              <!-- Pronoun is ma -->
              <when>
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="ما1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="اَمی1.1"/>
                    <clip pos="1" side="tl" part="whole"/>
                  </lu>
                </out>
              </when>
              <!-- Pronoun is shoma -->
              <when>
                <test>
                  <equal>
                    <clip pos="2" side="sl" part="lem"/>
                    <lit v="شما1.1"/>
                  </equal>
                </test>
                <out>
                  <!-- Output the Gilaki version w/ appropriate tag -->
                  <lu>
                    <lit v="شیمی1.1"/>
                    <clip pos="1" side="tl" part="whole"/>
                  </lu>
                </out>
              </when>
              <!-- switch prep and pronoun with genitive suffix in between -->
              <otherwise>
                <out>
                  <lu>
                    <clip pos="2" side="tl" part="whole"/>
                    <lit-tag v="gen"/>
                    <clip pos="1" side="tl" part="lem"/>  <!-- I think we only need the lemma. We won't have suffixes, enclitics? Usually? -->
                    <clip pos="1" side="tl" part="tl_pos"/>
                  </lu>
                </out>
              </otherwise>
            </choose>
          </when>
          <!-- Leave the order the same -->
          <otherwise>
            <out>
              <lu>
                <clip pos="1" side="tl" part="whole"/>
              </lu>
              <b/>
              <lu>
                <clip pos="2" side="tl" part="whole"/>
              </lu>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>
    <rule comment="3.3-handle preposition and an indefinite noun - change to postposition where needed"> 
      <pattern>
        <pattern-item n="prep"/>
        <pattern-item n="nom_ind"/>
      </pattern>
      <action>
        <choose>
          <!-- If the prep corresponds to a postposition put it after the pronoun -->
          <when>
            <test>
              <equal>
                <clip pos="1" side="tl" part="tl_pos"/>
                <lit-tag v="post"/>
              </equal>
            </test>
            <choose>
              <!-- See if the nominal ends with a vowel -->
              <when>
                <test> <!-- need to also make sure there are no suffixes? -->
                  <ends-with-list>
                    <clip pos="2" side="tl" part="lem"/>
                    <list v="end_vowels"/>
                  </ends-with-list>
                </test>
                <!-- switch prep and pronoun with _no_ genitive suffix in between -->
                <out>
                  <lu>
                    <lit v="ایتأ1.2"/>   
                    <lit-tag v="indf"/>
                  </lu>
                  <b/>
                  <lu>
                    <clip pos="2" side="tl" part="lem"/>   
                    <clip pos="2" side="tl" part="tl_pos"/>   
                    <clip pos="2" side="tl" part="nbr"/>   <!-- if it exists -->
                    <clip pos="2" side="tl" part="ezafe"/> <!-- possible ezafe -->
                  </lu>
                  <b/>
                  <lu>
                    <clip pos="1" side="tl" part="lem"/>  
                    <clip pos="1" side="tl" part="tl_pos"/>
                  </lu>
                </out>
              </when>
              <otherwise> <!-- no vowel -->
                <!-- switch prep and pronoun with genitive suffix in between -->
                <out>
                  <lu>
                    <lit v="ایتأ1.2"/>   
                    <lit-tag v="indf"/>
                  </lu>
                  <b/>
                  <lu>
                    <clip pos="2" side="tl" part="lem"/>   
                    <clip pos="2" side="tl" part="tl_pos"/>   
                    <clip pos="2" side="tl" part="nbr"/>   <!-- if it exists -->
                    <clip pos="2" side="tl" part="ezafe"/> <!-- possible ezafe -->
                    <lit-tag v="gen"/>
                  </lu>
                  <b/>
                  <lu>
                    <clip pos="1" side="tl" part="lem"/>  
                    <clip pos="1" side="tl" part="tl_pos"/>
                  </lu>
                </out>
              </otherwise>
            </choose>
          </when>
          <!-- Leave the order the same -->
          <otherwise>
            <out>
              <lu>
                <clip pos="1" side="tl" part="whole"/>
              </lu>
              <b/>
              <lu>
                <lit v="ایتأ1.2"/>   
                <lit-tag v="indf"/>
              </lu>
              <b/>
              <lu>
                <clip pos="2" side="tl" part="lem"/>   
                <clip pos="2" side="tl" part="tl_pos"/>   
                <clip pos="2" side="tl" part="nbr"/>   <!-- if it exists -->
                <clip pos="2" side="tl" part="ezafe"/> <!-- possible ezafe -->
              </lu>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>
    <rule comment="3.5-handle preposition and a noun - change to postposition where needed"> 
      <pattern>
        <pattern-item n="prep"/>
        <pattern-item n="nom"/>
      </pattern>
      <action>
        <!-- set the gen_pro variable if there's a pron. enclitic -->
        <call-macro n="gen_pro_macro">
            <with-param pos="2"/>
        </call-macro>
        <choose>
          <when> <!-- If the prep corresponds to a postposition put it after the nominal -->
            <test>
              <equal>
                <clip pos="1" side="tl" part="tl_pos"/>
                <lit-tag v="post"/>
              </equal>
            </test>
            <choose>
              <!-- See if the nominal ends with a vowel -->
              <when>
                <test> 
                  <ends-with-list>
                    <clip pos="2" side="tl" part="lem"/>
                    <list v="end_vowels"/>
                  </ends-with-list>
                </test>
                <!-- switch prep and pronoun with _no_ genitive suffix in between -->
                <out>
                  <lu>
                    <var n="gen_pro"/>  <!-- these two might be blank -->
                    <var n="gram_cat"/>  
                    <clip pos="2" side="tl" part="lem"/>   
                    <clip pos="2" side="tl" part="tl_pos"/>   
                    <clip pos="2" side="tl" part="nbr"/>   <!-- if it exists -->
                  </lu>
                  <b/>
                  <lu>
                    <clip pos="1" side="tl" part="lem"/>  
                    <clip pos="1" side="tl" part="tl_pos"/>
                  </lu>
                </out>
              </when>
              <otherwise> <!-- no vowel -->
                <!-- switch prep and pronoun with genitive suffix in between -->
                <out>
                  <lu>
                    <var n="gen_pro"/>  <!-- these two might be blank -->
                    <var n="gram_cat"/>  
                    <clip pos="2" side="tl" part="lem"/>   
                    <clip pos="2" side="tl" part="tl_pos"/>   
                    <clip pos="2" side="tl" part="nbr"/>   <!-- if it exists -->
                    <lit-tag v="gen"/>
                  </lu>
                  <b/>
                  <lu>
                    <clip pos="1" side="tl" part="lem"/>  
                    <clip pos="1" side="tl" part="tl_pos"/>
                  </lu>
                </out>
              </otherwise>
            </choose>
          </when>
          <!-- Leave the order the same -->
          <otherwise>
            <out>
              <lu>
                <clip pos="1" side="tl" part="whole"/>
              </lu>
              <b/>
              <lu>
                <var n="gen_pro"/>  <!-- these two might be blank -->
                <var n="gram_cat"/>  
                <clip pos="2" side="tl" part="lem"/>   
                <clip pos="2" side="tl" part="tl_pos"/>   
                <clip pos="2" side="tl" part="nbr"/>   <!-- if it exists -->
              </lu>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>
    <rule comment="4-past continuous (mi- prefix)"> 
      <pattern>
        <pattern-item n="vrb-ipfv"/>
      </pattern>
      <action>
        <call-macro n="2_3_pl_macro">
            <with-param pos="1"/>
        </call-macro>
        <!-- regarding 3sg past. It comes in from the Farsi as 3sg_pst. We change it to 3sg for most of the verbs.
             Here, however we don't need to change it because it is always going to be null for 3sg past so we'll
             let it go through as 3sg_pst -->
        <out>
          <lu>
            <!-- don't output <pfv> and do output <ipfv> just before the per-nbr -->
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> <!-- note: we are not outputting <pst> that's part of the category name (i.e. vpst) -->
            <clip pos="1" side="tl" part="neg"/> <!-- if it's present, output it -->
            <clip pos="1" side="tl" part="caus"/>
            <clip pos="1" side="tl" part="ipfv"/>
            <var n="per_number"/>
          </lu>
        </out>
      </action>
    </rule>
    <rule comment="5-verbs in the infinitive (pst stem)"> 
      <!-- This is pretty vanilla except that we don't output pfv like in the normal pst and we add the possible ezafe 
           if it wasn't for the fact that we are removing the pst and prs tags we could have use 'whole' to output the whole word -->
      <pattern>
        <pattern-item n="vrb-inf"/>
      </pattern>
      <action>
        <out>
          <lu>
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> <!-- note: we are not outputting <pst> that's part of the category name (i.e. vpst) -->
            <clip pos="1" side="tl" part="neg"/> <!-- if it's present, output it -->
            <clip pos="1" side="tl" part="caus"/>
            <clip pos="1" side="tl" part="per-nbr"/>
            <clip pos="1" side="tl" part="ezafe"/> <!-- possible ezafe after infinitives -->
          </lu>
        </out>
      </action>
    </rule>
    <rule comment="6-verbs with copular past tense stems"> 
      <!-- We need this in addition to the general past tense rule because for copular past we don't wan the pfv prefix added 
           this could be possibly handled in the past tense rule. -->
      <pattern>
        <pattern-item n="vrb-cop-pst"/>
      </pattern>
      <action>
        <call-macro n="2_3_pl_macro">
            <with-param pos="1"/>
        </call-macro>
        <call-macro n="3sg_pst_macro">
            <with-param pos="1"/>
        </call-macro>
        <out>
          <lu>
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> <!-- note: we are not outputting <pst> that's part of the category name (i.e. vpst) -->
            <clip pos="1" side="tl" part="neg"/> <!-- if it's present, output it -->
            <var n="per_number"/>
          </lu>
        </out>
      </action>
    </rule>
    <rule comment="7-verbs with past tense stems"> 
      <pattern>
        <pattern-item n="vrb-pst"/>
      </pattern>
      <action>
        <call-macro n="2_3_pl_macro">
            <with-param pos="1"/>
        </call-macro>
        <call-macro n="3sg_pst_macro">
            <with-param pos="1"/>
        </call-macro>
        <out>
          <lu>
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> <!-- note: we are not outputting <pst> that's part of the category name (i.e. vpst) -->
            <clip pos="1" side="tl" part="neg"/> <!-- if it's present, output it -->
            <lit-tag v="pfv"/>
            <clip pos="1" side="tl" part="caus"/>
            <var n="per_number"/>
          </lu>
        </out>
      </action>
    </rule>
    <!-- this needs to come before the present pattern -->
    <rule comment="8-verbs with present participle ending -an"> 
      <pattern>
        <pattern-item n="vrb-prpt"/>
      </pattern>
      <action>
        <out>
          <lu>
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> 
            <clip pos="1" side="tl" part="prpt"/> 
          </lu>
        </out>
      </action>
    </rule>
    <!-- this needs to come before the present pattern -->
    <rule comment="9-verbs with imperative ending"> 
      <pattern>
        <pattern-item n="vrb-imp"/>
      </pattern>
      <action>
        <out>
          <lu>
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> <!-- note: we are not outputting <prs> that's part of the category name (i.e. vprs) -->
            <clip pos="1" side="tl" part="neg"/> <!-- if it's present, output it -->
            <lit-tag v="imp"/> <!-- change sbjv to imp. Note Farsi never has an imp prefix in the analysis -->
            <clip pos="1" side="tl" part="caus"/>
            <lit-tag v="2sg_imp"/> <!-- change imp to 2sg_imp. Note that we don't get imp for 2pl. In the Farsi analysis it just comes out 2pl -->
          </lu>
        </out>
      </action>
    </rule>
    <rule comment="10-verbs with present tense stems"> 
      <pattern>
        <pattern-item n="vrb-prs"/>
      </pattern>
      <action>
        <call-macro n="2_3_pl_macro">
            <with-param pos="1"/>
        </call-macro>
        <choose>
          <!-- If the caus is present, change it to caus from caus_pst -->
          <when>
            <test>
              <equal>
                <clip pos="1" side="sl" part="caus"/>
                <lit-tag v="caus_pst"/>
              </equal>
            </test>
            <let>
              <var n="caus_var"/>
              <lit-tag v="caus"/>
            </let>
            <choose>
              <!-- If the suffix is 3sg_pst, change it to 3sg -->
              <when>
                <test>
                  <equal>
                    <clip pos="1" side="sl" part="per-nbr"/>
                    <lit-tag v="3sg_pst"/>
                  </equal>
                </test>
                <let>
                  <var n="per_number"/>
                  <lit-tag v="3sg"/>
                </let>
              </when>
            </choose>
          </when>
        </choose>
        <choose>
          <!-- If the suffix is 3sg_prs, change it to 3sg -->
          <when>
            <test>
              <equal>
                <clip pos="1" side="sl" part="per-nbr"/>
                <lit-tag v="3sg_prs"/>
              </equal>
            </test>
            <let>
              <var n="per_number"/>
              <lit-tag v="3sg"/>
            </let>
          </when>
        </choose>
        <out>
          <lu>
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> <!-- note: we are not outputting <prs> that's part of the category name (i.e. vprs) -->
            <clip pos="1" side="tl" part="neg"/> <!-- if it's present, output it -->
            <clip pos="1" side="tl" part="sbjv"/> <!-- if it's present, output it -->
            <var n="caus_var"/>
            <var n="per_number"/>
          </lu>
        </out>
      </action>
    </rule>
    <rule comment="11-copular with present tense stem"> 
      <pattern>
        <pattern-item n="vrb-cop-prs"/>
      </pattern>
      <action>
        <call-macro n="2_3_pl_macro">
            <with-param pos="1"/>
        </call-macro>
        <choose>
          <!-- If the suffix is 3sg_cop_prs, change it to 3sg -->
          <when>
            <test>
              <equal>
                <clip pos="1" side="sl" part="per-nbr"/>
                <lit-tag v="3sg_cop_prs"/>
              </equal>
            </test>
            <let>
              <var n="per_number"/>
              <lit-tag v="3sg"/>
            </let>
          </when>
        </choose>
        <out>
          <lu>
            <clip pos="1" side="tl" part="lem"/>
            <clip pos="1" side="tl" part="tl_pos"/> <!-- note: we are not outputting <prs> that's part of the category name (i.e. vprs) -->
            <clip pos="1" side="tl" part="neg"/> <!-- if it's present, output it -->
            <var n="per_number"/> <!-- per-nbr -->
          </lu>
        </out>
      </action>
    </rule>
    <rule comment="12-X plus copular 3sg pres (ast). Make it an enclitic"> 
      <pattern>
        <pattern-item n="x"/> <!-- many different pos's -->
        <pattern-item n="vrb-cop-prs-3sg"/>
      </pattern>
      <action>
        <out>
          <lu>
            <clip pos="1" side="tl" part="whole"/>
            <lit-tag v="be_prs_3sg"/> <!-- copular enclitic -->
          </lu>
        </out>
      </action>
    </rule>

  </section-rules>
</transfer>
<!--    <rule comment="1-handle switching n adj to adj n in some cases"> 
      <pattern>
        <pattern-item n="nom"/>
        <pattern-item n="adj"/>
      </pattern>
      <action>
        <choose>
          ** If the adj is in the list ***
          <when>
            <test>
              <in>
                <clip pos="2" side="sl" part="lem"/>
                <list v="rev_adjs"/>
              </in>
            </test>
            ** reverse the two putting ezafes where they should go ***
            <out>
              <lu>
                <clip pos="2" side="tl" part="lem"/>  
                <clip pos="2" side="tl" part="tl_pos"/>  
                <clip pos="2" side="tl" part="nbr"/>   ** if it exists ***
                <clip pos="1" side="tl" part="ezafe"/> ** there should be an ezafe on the noun, put it on the adj *** 
                <clip pos="1" side="tl" part="lem"/>   
                <clip pos="1" side="tl" part="tl_pos"/>   
                <clip pos="1" side="tl" part="nbr"/>   ** if it exists ***
                <clip pos="2" side="tl" part="ezafe"/> ** if it exists *** 
              </lu>
            </out>
          </when>

          <otherwise>
            <out>
              <lu>
                <clip pos="1" side="tl" part="whole"/>
                <clip pos="2" side="tl" part="whole"/>
              </lu>
            </out>
          </otherwise>
        </choose>
      </action>
    </rule>
-->
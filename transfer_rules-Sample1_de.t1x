<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE transfer PUBLIC "-//XMLmind//DTD transfer//EN"
"transfer.dtd">
<transfer
><section-def-cats
><def-cat
n="c_adj"
><cat-item
tags="adj"
></cat-item
><cat-item
tags="adj.*"
></cat-item
></def-cat
><def-cat
n="c_adv"
><cat-item
tags="adv"
></cat-item
></def-cat
><def-cat
n="c_def"
><cat-item
tags="def"
></cat-item
><cat-item
tags="def.*"
></cat-item
></def-cat
><def-cat
n="c_dem"
><cat-item
tags="dem"
></cat-item
><cat-item
tags="dem.*"
></cat-item
></def-cat
><def-cat
n="c_det"
><cat-item
tags="det"
></cat-item
><cat-item
tags="det.*"
></cat-item
></def-cat
><def-cat
n="c_indf"
><cat-item
tags="indf"
></cat-item
><cat-item
tags="indf.*"
></cat-item
></def-cat
><def-cat
n="c_n"
><cat-item
tags="n"
></cat-item
><cat-item
tags="n.*"
></cat-item
></def-cat
><def-cat
n="c_pro"
><cat-item
tags="pro"
></cat-item
><cat-item
tags="pro.*"
></cat-item
></def-cat
><def-cat
n="c_sample"
><!--Dieses Tags-Element stimmt mit Wörtern (lexikalischen Einheiten) überein, die 'samp' als grammatische Kategorie (immer das erste Tag) und keine weiteren Tags haben, d.h. nur 'samp'.--><cat-item
tags="samp"
></cat-item
><!--Dieses Tags-Element stimmt mit Wörtern (lexikalischen Einheiten) überein, die 'word1.2' als Lemma und 'samp' als grammatische Kategorie (keine weiteren Tags) haben.--><cat-item
lemma="word1.2"
tags="samp"
></cat-item
><!--Dieses Tags-Element stimmt mit Wörtern überein, die 'samp' als grammatische Kategorie und beliebig viele weitere Tags (z.B. Affixe, Merkmale, Klassen, usw.) haben.--><!--Zum Beispiel würde Folgendes übereinstimmen: 'samp pst', 'samp pst inf', usw.--><cat-item
tags="samp.*"
></cat-item
><!--Dieses Tags-Element stimmt mit Wörtern überein, die 'samp' als grammatische Kategorie, 'pst' als nächstes Tag und beliebig viele weitere Tags haben.--><cat-item
tags="samp.pst.*"
></cat-item
><!--Dieses Tags-Element stimmt mit Wörtern überein, die 'samp' als grammatische Kategorie und 'pst' irgendwo in den folgenden Tags haben, d.h. beliebige Tags vor und nach 'pst'.--><cat-item
tags="samp.*.pst.*"
></cat-item
></def-cat
><def-cat
n="c_v"
><cat-item
tags="v"
></cat-item
><cat-item
tags="v.*"
></cat-item
></def-cat
></section-def-cats
><section-def-attrs
><def-attr
n="a_case_feature"
><attr-item
tags="acc"
></attr-item
><attr-item
tags="dat"
></attr-item
><attr-item
tags="nom"
></attr-item
></def-attr
><def-attr
n="a_gender_feature"
><attr-item
tags="?"
></attr-item
><attr-item
tags="f"
></attr-item
><attr-item
tags="m"
></attr-item
></def-attr
><def-attr
n="a_gram_cat"
><attr-item
c="Adverb"
tags="adv"
></attr-item
><attr-item
c="Demonstrative"
tags="def"
></attr-item
><attr-item
c="Demonstrative"
tags="dem"
></attr-item
><attr-item
c="Noun"
tags="n"
></attr-item
><attr-item
c="Pronoun"
tags="pro"
></attr-item
><attr-item
c="Pro-form"
tags="pro-form"
></attr-item
><attr-item
c="Verb"
tags="v"
></attr-item
></def-attr
><def-attr
n="a_number_feature"
><attr-item
tags="?"
></attr-item
><attr-item
tags="pl"
></attr-item
><attr-item
tags="sg"
></attr-item
></def-attr
><def-attr
n="a_person_feature"
><attr-item
tags="1"
></attr-item
><attr-item
tags="2"
></attr-item
><attr-item
tags="3"
></attr-item
></def-attr
><def-attr
n="a_Verb_class"
><attr-item
tags="AR"
></attr-item
><attr-item
tags="ER"
></attr-item
><attr-item
tags="IR"
></attr-item
></def-attr
><def-attr
n="a_sample"
><!--Das Attribut a_sample ist als die Sammlung der folgenden Tags (Symbole) definiert: 'abc', 'uvw', 'xyz'. Sie können dieses Attribut verwenden, um auf jedes Tag in dieser Menge von Tags zu verweisen.--><attr-item
tags="abc"
></attr-item
><attr-item
tags="uvw"
></attr-item
><attr-item
tags="xyz"
></attr-item
></def-attr
><def-attr
n="a_sample2"
><!--Das Attribut a_sample2 ist als die Sammlung der folgenden Tags (Symbole) definiert: 'agr1', 'agr2', 'agr3'. Sie können dieses Attribut verwenden, um auf jedes Tag in dieser Menge von Tags zu verweisen.--><attr-item
tags="agr1"
></attr-item
><attr-item
tags="agr2"
></attr-item
><attr-item
tags="agr3"
></attr-item
></def-attr
></section-def-attrs
><section-def-vars
><def-var
n="v_sample"
></def-var
></section-def-vars
><section-def-lists
><def-list
n="l_sample"
><list-item
v="stuff1"
></list-item
><list-item
v="stuff2"
></list-item
></def-list
></section-def-lists
><section-def-macros
><def-macro
n="m_sample"
npar="1"
><choose
><when
><test
><equal
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><lit-tag
v="sg"
></lit-tag
></equal
></test
><out
><lu
><clip
part="lem"
pos="1"
side="tl"
></clip
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
></lu
></out
></when
></choose
></def-macro
></section-def-macros
><section-rules
><rule
comment="Beispiel – Affix oder Merkmal mit let löschen">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Löschen Sie ein Affix von einer lexikalischen Einheit mit einem let-Element.--><let
><!--Geben Sie zuerst das an, was Sie löschen möchten. In diesem Fall ein Beispiel-Suffix (alles, was durch a_sample definiert ist).--><clip
part="a_sample"
pos="1"
side="tl"
></clip
><!--Geben Sie dann den 'Wert' an, den Sie dem Element geben möchten. In diesem Fall ein leerer String, der es aus der Ausgabe entfernt.--><!--Beachten Sie: Die Verwendung eines leeren Literal-Tags würde immer noch die < und > hinzufügen, die Tags umgeben, daher sollte eine Literalzeichenkette verwendet werden, um ein Tag zu löschen.--><lit
v=""
></lit
></let
></action
></rule>
<rule
comment="Verb – Spanisch (Merkmal löschen)">
<pattern
><pattern-item
n="c_v"
></pattern-item
></pattern
><action
><let
><clip
part="a_Verb_class"
pos="1"
side="tl"
></clip
><lit-tag
v=""
></lit-tag
></let
><out
><lu
><clip
part="whole"
pos="1"
side="tl"
></clip
></lu
></out
></action
></rule>
<rule
comment="Beispiel – Attributwert setzen">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Setzen Sie ein Attribut auf einen bestimmten Wert.--><let
><!--Geben Sie zuerst das an, was Sie ändern möchten. In diesem Fall das Beispielattribut.--><clip
part="a_sample"
pos="1"
side="tl"
></clip
><!--Geben Sie dann den Wert an, den Sie dem Element geben möchten. In diesem Fall 'abc'. WICHTIG: Der Wert im Literal-Tag muss einer der gültigen Werte in der durch a_sample definierten Menge sein.--><!--Auch WICHTIG: Wenn eines der durch a_sample definierten Attribute nicht am Wort (Zielwort in diesem Fall) vorhanden ist, hat eine Änderung keinen Effekt.--><lit-tag
v="abc"
></lit-tag
></let
></action
></rule>
<rule
comment="Beispiel – Zielwort vollständig ausgeben">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Geben Sie ein ganzes Zielwort aus--><out
><lu
><!--'whole' bedeutet das Lemma plus alle Tags, die damit vorhanden sind.--><clip
part="whole"
pos="1"
side="tl"
></clip
></lu
></out
></action
></rule>
<rule
comment="Beispiel – Zwei Zielwörter vollständig ausgeben">
<pattern
><pattern-item
n="c_sample"
></pattern-item
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Geben Sie zwei ganze Zielwörter aus--><out
><lu
><clip
part="whole"
pos="1"
side="tl"
></clip
></lu
><!--Sie möchten normalerweise ein Leerzeichen zwischen lexikalischen Einheiten ausgeben.--><b
></b
><lu
><!--Beachten Sie, dass das 2. Wort das Element 2 im oben übereinstimmenden 2-Wort-Muster ist--><clip
part="whole"
pos="2"
side="tl"
></clip
></lu
></out
></action
></rule>
<rule
comment="Beispiel – Wort und neues Affix ausgeben">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Geben Sie Wort 1 und ein zusätzliches Suffix aus--><out
><lu
><!--In FLExTrans sollte die minimale lexikalische Einheit, die Sie ausgeben, das Lemma (z.B. word2.3) plus die grammatische Kategorie sein.--><clip
part="lem"
pos="1"
side="tl"
></clip
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><!--Wir verwenden das Literal-Tag-Element, um ein Tag (Symbol) auszugeben. Hier soll das Plural-Affix am Wort ausgegeben werden.--><lit-tag
v="pl"
></lit-tag
></lu
></out
></action
></rule>
<rule
comment="Beispiel – Neues Wort ausgeben">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Geben Sie ein neues Wort aus (ignorieren Sie die Eingabeelemente)--><out
><lu
><!--In FLExTrans sollte die minimale lexikalische Einheit, die Sie ausgeben, das Lemma (z.B. word2.3) plus die grammatische Kategorie sein.--><!--Anstelle von clip...lem können wir das Literal-String-Element verwenden, um ein Lemma unserer Wahl auszugeben. Dieses Lemma sollte zum Ziel-FLEx-Projekt passen.--><!--Hier geben wir die 4. Bedeutung des 1. Homographen für 'word' aus--><lit
v="word1.4"
></lit
><!--Anstelle von clip...a_gram_cat sollte dies die grammatische Kategorie sein, die zu word1.4 im Ziel-FLEx-Projekt passt. Hier sagen wir, die Kategorie ist Verb.--><lit-tag
v="v"
></lit-tag
><!--Wir verwenden das Literal-Tag-Element, um ein Tag (Symbol) auszugeben. Hier soll das Plural-Affix am Wort ausgegeben werden.--><lit-tag
v="pl"
></lit-tag
></lu
></out
></action
></rule>
<rule
comment="Beispiel – Groß-/Kleinschreibung ändern">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Ändern Sie den Kasus des ersten Elements (Lemma), um den Kasus des zweiten Elements (Literalzeichenkette) zu übernehmen.
Das Folgende wird das Lemma großschreiben. Die Verwendung von 'aa' macht es klein. 'AA' würde das Lemma komplett groß schreiben.--><!--Anstelle einer Literalzeichenkette könnten Sie alternativ eine Variable verwenden, damit das Lemma den Kasus der Variablen übernimmt.--><modify-case
><clip
part="lem"
pos="1"
side="tl"
></clip
><lit
v="Aa"
></lit
></modify-case
></action
></rule>
<rule
comment="Beispiel – 2-Wege-If mit Ausgabe">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Wenn X, dann A ausgeben, sonst B--><choose
><!--Erster Test--><when
><test
><!--Verwenden Sie den equal-Block, um zu prüfen, ob zwei Dinge gleich sind--><equal
><clip
part="a_sample"
pos="1"
side="tl"
></clip
><lit-tag
v="uvw"
></lit-tag
></equal
></test
><!--Alles, was dem Test-Block folgt, wird ausgeführt, wenn die obigen Dinge gleich sind
Dieses spezielle Beispiel gibt das Zielwort nach Teilen aus, mit einem bestimmten Literal-Tag für das Affix.--><out
><lu
><clip
part="lem"
pos="1"
side="tl"
></clip
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><lit-tag
v="agr1"
></lit-tag
></lu
></out
></when
><!--Wenn alle when-Blöcke oben fehlschlagen, wird diese Logik unten ausgeführt--><otherwise
><!--Dieses spezielle Beispiel gibt das Zielwort nach Teilen aus, mit einem anderen Literal-Tag für das Affix.--><out
><lu
><clip
part="lem"
pos="1"
side="tl"
></clip
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><lit-tag
v="agr2"
></lit-tag
></lu
></out
></otherwise
></choose
></action
></rule>
<rule
comment="Beispiel – 3-Wege-Auswahl mit let">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Wenn X let A, wenn Y let B, sonst let C. Dann ausgeben.--><choose
><when
><test
><!--Verwenden Sie den equal-Block, um zu prüfen, ob zwei Dinge gleich sind--><equal
><clip
part="a_sample"
pos="1"
side="tl"
></clip
><lit-tag
v="uvw"
></lit-tag
></equal
></test
><!--Alles, was dem Test-Block folgt, wird ausgeführt, wenn die obigen Dinge gleich sind
Dieses spezielle Beispiel setzt eines der Elemente des Zielworts auf ein Tag (Merkmal oder Glosse eines Affixes).--><let
><clip
part="a_sample2"
pos="1"
side="tl"
></clip
><lit-tag
v="agr1"
></lit-tag
></let
></when
><!--Wenn der when-Block oben fehlschlägt (die beiden Dinge waren nicht gleich), versuchen Sie diesen Test unten--><when
><test
><equal
><clip
part="a_sample"
pos="1"
side="tl"
></clip
><lit-tag
v="xyz"
></lit-tag
></equal
></test
><let
><clip
part="a_sample2"
pos="1"
side="tl"
></clip
><lit-tag
v="agr2"
></lit-tag
></let
></when
><!--Wenn alle when-Blöcke oben fehlschlagen, wird diese Logik unten ausgeführt--><!--Dieses spezielle Beispiel setzt einen Wert, der anzeigt, dass etwas Unerwartetes aufgetreten ist.--><!--Es ist eine gute "sonst"-Bedingung.--><otherwise
><let
><clip
part="a_sample2"
pos="1"
side="tl"
></clip
><lit-tag
v="agr3"
></lit-tag
></let
></otherwise
></choose
><out
><lu
><clip
part="whole"
pos="1"
side="tl"
></clip
></lu
></out
></action
></rule>
<rule
comment="Beispiel – If-Anweisungen mit verschiedenen Tests">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Wenn mit anderen Dingen als equals--><choose
><when
><test
><and
><begins-with
><!--Verwenden Sie begins with, wenn Sie nur den Anfang von etwas abgleichen möchten, wie in diesem Fall die grammatische Kategorie--><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><lit-tag
v="x"
></lit-tag
></begins-with
><ends-with
><!--Verwenden Sie ends with, wenn Sie nur das Ende von etwas abgleichen möchten, wie in diesem Fall das Lemma. Denken Sie daran, dass alle Lemmata mit X.X enden werden.--><clip
part="lem"
pos="1"
side="tl"
></clip
><lit
v="ing1.1"
></lit
></ends-with
><begins-with-list
><!--Verwenden Sie begins with something in list, wenn Sie den Anfang des ersten Elements abgleichen möchten. Der zu vergleichende Text kann alles in der angegebenen Liste sein. Die Liste ist oben definiert.--><var
n="v_sample"
></var
><list
n="l_sample"
></list
></begins-with-list
><ends-with-list
><!--Verwenden Sie ends with something in list, wenn Sie das Ende des ersten Elements abgleichen möchten. Der Vergleich kann alles in der angegebenen Liste sein. Die Liste ist oben definiert.--><clip
part="lem"
pos="1"
side="tl"
></clip
><list
n="l_sample"
></list
></ends-with-list
><in
><!--Verwenden Sie in list, um zu sehen, ob das erste Element eines der Dinge in der angegebenen Liste ist.--><clip
part="lem"
pos="1"
side="tl"
></clip
><list
n="l_sample"
></list
></in
><contains-substring
><!--Wenn Sie contains substring verwenden, können Sie prüfen, ob die zweite angegebene Zeichenkette irgendwo im ersten Element enthalten ist.--><var
n="v_sample"
></var
><lit
v="abc"
></lit
></contains-substring
></and
></test
><!--Alles, was dem Test-Block folgt, wird ausgeführt, wenn die obige Bedingung wahr ist. In diesem Fall müssten alle oben genannten Prüfungen wahr sein, damit die Ausgabe erfolgt.--><out
><lu
><clip
part="whole"
pos="1"
side="tl"
></clip
><lit-tag
v="agr1"
></lit-tag
></lu
></out
></when
></choose
></action
></rule>
<rule
comment="Beispiel – If-Anweisungen mit und/oder/nicht">
<pattern
><pattern-item
n="c_sample"
></pattern-item
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Wenn X und Y, dann A ausgeben--><choose
><when
><test
><!--Verwenden Sie den and-Block, um zu prüfen, ob zwei Bedingungen wahr sind. Sie können weitere equal-Blöcke hinzufügen, wenn gewünscht.--><and
><equal
><clip
part="a_sample"
pos="1"
side="tl"
></clip
><lit-tag
v="uvw"
></lit-tag
></equal
><equal
><clip
part="a_sample"
pos="2"
side="tl"
></clip
><lit-tag
v="xyz"
></lit-tag
></equal
></and
></test
><!--Alles, was dem Test-Block folgt, wird ausgeführt, wenn die obige Bedingung wahr ist--><out
><lu
><clip
part="lem"
pos="1"
side="tl"
></clip
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><lit-tag
v="agr1"
></lit-tag
></lu
></out
></when
></choose
><!--Wenn X oder Y, dann A ausgeben--><choose
><when
><test
><!--Verwenden Sie den or-Block, um zu prüfen, ob zwei Bedingungen wahr sind. Sie können weitere equal-Blöcke hinzufügen, wenn gewünscht.--><or
><equal
><clip
part="a_sample"
pos="1"
side="tl"
></clip
><lit-tag
v="uvw"
></lit-tag
></equal
><equal
><clip
part="a_sample"
pos="2"
side="tl"
></clip
><lit-tag
v="xyz"
></lit-tag
></equal
></or
></test
><!--Alles, was dem Test-Block folgt, wird ausgeführt, wenn die obige Bedingung wahr ist--><out
><lu
><clip
part="lem"
pos="1"
side="tl"
></clip
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><lit-tag
v="agr2"
></lit-tag
></lu
></out
></when
></choose
><!--Wenn nicht X, dann A ausgeben--><choose
><when
><test
><!--Verwenden Sie den not-Block, um zu prüfen, ob zwei Dinge nicht gleich sind--><not
><equal
><clip
part="a_sample"
pos="1"
side="tl"
></clip
><lit-tag
v="uvw"
></lit-tag
></equal
></not
></test
><!--Alles, was dem Test-Block folgt, wird ausgeführt, wenn die obige Bedingung wahr ist--><out
><lu
><clip
part="lem"
pos="1"
side="tl"
></clip
><clip
part="a_gram_cat"
pos="1"
side="tl"
></clip
><lit-tag
v="agr3"
></lit-tag
></lu
></out
></when
></choose
></action
></rule>
<rule
comment="Beispiel – Makro aufrufen, um eine Bedingung zu testen und auszugeben">
<pattern
><pattern-item
n="c_sample"
></pattern-item
></pattern
><action
><!--Rufen Sie ein Makro mit einem Element auf; wenn das Muster 2 Elemente enthält, muss das Makro möglicherweise mit 2 Elementen aufgerufen werden--><call-macro
n="m_sample"
><with-param
pos="1"
></with-param
></call-macro
></action
></rule
></section-rules
></transfer
>